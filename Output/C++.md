# C++
## 一些小问题
#### 随机数
1. srand(...)设置种子
2. rand()生成实际的随机数
#### 野指针问题
- 创建指针后要初始化为NULL，否则他的缺省值是随机的。
- 当使用delete释放空间后，要设为NULL，否则会被随机分配，可能导致和其他指针指向同一块地址，造成后续访问或者写入冲突。
#### 一个类A包含另一个已经包含类A的类B
- 直接include会导致死循环，编译错误。
- 解决方法
    - 在类A头文件中声明类B
    ``` C++
    #ifndef AH
    #define AH
    class B;
    class A {
    public:
        B* b;
        ~A();
    };
    #endif
    ```
    - 在类A的cpp文件中除了包含类A，还要**包含类B**
    ``` C++
    #include "A.h"
    #include "B.h"
    A::~A() {
    }
    ```
#### 内存对齐
- 作用：
    - 减少cpu的读取次数
- 根据有效对齐单位确定 #pragma back(n)，一般是4个字节
- [参考](https://zhuanlan.zhihu.com/p/30007037)
#### sizeof
*所占内存的字节数*
- 指针：无论指向什么类型，都是4个字节。
- 引用：引用的对象的类型大小
- 数组名：整个数组占的字节
- 结构体：要注意内存对齐问题
#### 深复制 vs 浅复制
- 将对象所持有的其它资源一并拷贝的行为叫做**深复制**，我们必须显式地定义拷贝构造函数才能达到深复制的目的
- 如果类的成员变量有指针类型，**深复制**使得，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象
- 如果类的成员变量没有指针，使用一般的拷贝构造函数，浅复制足以
#### 共享变量
##### static ▲
1. 修饰**局部变量**时，仅在第一次被调用时初始化，第二次调用不会再初始化。可以在不同的函数调用之间保持局部变量的值，即不需要再每次进入和离开作用域时重复进行创建和销毁
2. 修饰**全局变量**时，作用域为**声明它的文件**，只可以被当前文件访问；而不加static的全局变量，可以被其他文件访问
3. 可以用于**类**的数据成员（成员函数和成员变量）上，表示被类的所有对象共享
##### extern ▲
- 提供全局变量的引用
- 对**所有的程序文件**都可见

#### 强制类型转换
##### static_cast
- 低风险的类型转换：整型、浮点型、字符之间的转换
##### reinterpret_cast
- 逐个比特复制：不同类型的指针、不同类型的引用之间的转换
##### dynamic_cast
- 专门用于将基类指针转换为子类指针，会检查安全性，不安全则返回空指针；reinterpret_cast不会检查安全性
- 对于将基类引用转换为子类引用，会直接抛出异常，因为没有空引用可以返回

#### 定义常量 √ √ √ √
##### const
- const的初始化：const对象一旦创建就不能修改，所以const对象一定要初始化，可以用非const对象来初始化。
- const的作用域：只在创建const对象的文件内有效。可以用extern关键字来声明const 变量，使得可以在不同文件之间共享。
- const与引用：
    - 对常量的引用必须用const引用
    ``` C++
    const int a=42;
    const int&b=a;
    ```
    - const引用不能修改所引用的值
- const与指针
    - 指向常量的指针必须用const指针（即常量指针）
    ``` C++
    const int a=42;
    const int* b=&a;
    ```
    - 常量指针 vs 指针常量
        - 常量指针：指向常量的指针
        - 指针常量：指针保存（指向）的地址是常量
        ``` C++
        int num=0;
        const int* ptr1=&num; // 常量指针->(const int)* ptr1
        int* const ptr2=&num; // 指针常量，一直指向num地址->int* (const ptr2)
        ```
- const与函数参数
    - 注意常量引用不能赋给非常量引用
    - 注意常量指针不能赋给非常量指针
- const与类
    - const成员变量：在类的定义中声明const类型，但是不可以初始化，必须在构造函数中初始化。
    - const成员函数：不可以修改数据成员，不可以调用非const成员函数。

##### #define 宏
- 宏/常量：使用#define来创建符号常量
``` C++
#include <iostream>
using namespace std;
 
#define PI 3.14159
 
int main ()
{
 
    cout << "Value of PI :" << PI << endl; 
 
    return 0;
}
```
- 参数宏：使用#define来定义一个带有参数的宏，相当于函数来使用
``` C++
#include <iostream>
using namespace std;
 
#define MIN(a,b) (a<b ? a : b)
 
int main ()
{
   int i, j;
   i = 100;
   j = 30;
   cout <<"较小的值为：" << MIN(i, j) << endl;
 
    return 0;
}
```
#### 指针 vs 引用
##### 指针
- 指针 vs 数组名
    - 指向数组开头的指针可以通过指针的算术运算来访问数组
    - 数组名也可以应用*，+，-等运算符，但不可以使用++，--，因为修改数组名的值是非法的，数组名是一个指向数组开头的**常量**，不能作为左值
- 指向指针的指针
冷静区别 & 是对变量取地址，* 是对变量取值即可。
#### 引用
引用相当于是一个变量的别名。
#### 指针和引用的区别 √ √
- 引用必须是对一个已有对象的引用，不存在空引用。可以有空指针，而且最好在创建指针时初始化为NULL。
- 引用必须在创建时初始化。指针可以随时初始化。
- 一旦引用被初始化为一个对象，就**不会**改变为对另一个对象的引用。指针可以随时指向另一个对象。
- 指针有自己的一块空间，而引用只是一个别名，它们共享一块空间。sizeof(指针)为4，而sizeof(引用)为引用对象的大小。

#### struct vs class
- struct只包含成员变量，不包含成员函数；默认成员属性是public
- class包含成员变量和成员函数；默认成员属性是private

## C++函数
#### 函数传参
##### 传值调用
- 将参数的实际**值**复制给函数的形式参数
- 修改函数内的形式参数**不会**影响实际参数
##### 指针调用
- 将参数的**地址**复制给函数的形式参数
- 因此，修改函数内的形式参数**会影响**到实际参数
##### 引用调用 √
- 将引用的**地址**复制给函数的形式参数，该引用用于访问调用中要用到的实际参数
- 因此，修改函数内的形式参数**会影响**实际参数
##### 同等情况下，为什么传引用会更好？
- 传引用时，实际上是通过形参作为实参的别名，**不需要额外分配空间存放实参的副本**，函数内对形参的操作实际上是对实参的操作，节省空间开销。
##### 传递数组 √
*实际上传的都是地址*
1. 形式参数是一个指针
``` C++
void myFunction(int *param)
{
}
```
2. 形式参数是一个已定义大小的数组
``` C++
void myFunction(int param[10])
{
}
```
3. 形式参数是一个未定义大小的数组
``` C++
void myFunction(int param[])
{
}
```
#### 函数返回值
##### 返回数组/指针 √
*C++不允许返回一个完整的数组，可以通过数组名返回一个指向数组的指针*
``` C++
int * getRandom( )
{
  static int  r[10];
 
  // 设置种子
  srand( (unsigned)time( NULL ) );
  for (int i = 0; i < 10; ++i)
  {
    r[i] = rand();
    cout << r[i] << endl;
  }
 
  return r;
}
```
##### 返回引用
*跟返回指针类似*
``` C++
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}
```
*返回的被引用的对象不能超过作用域，即返回函数内的局部变量的引用是非法的*
``` C++
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```


## C++数据抽象 & 数据封装
- 数据抽象：仅向用户暴露接口而隐藏具体的实现细节的机制。用**类**来定义抽象的数据类型。
- 数据封装：把数据和操作数据的函数捆绑在一起的机制。

## C++抽象类
- 含有至少一个**纯虚函数**
- **不可以被实例化**
- 被当作**接口**来使用

## C++面向对象——类
#### 访问修饰符
- public 公有成员：在类的外部可访问
- private 私有成员：类定义中未加修饰符的**默认为私有**，除了**类内部和友元函数**，在类的外部不可访问
- protected 受保护成员：除了**派生类**，在类的外部不可访问
#### 类的继承
- is a关系
- 可以多继承
``` C++
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```
- 继承类别
    - public 继承：基类public，protected，private ->派生类public，protected，private
    - protected 继承：基类public，protected，private ->派生类protected，protected，private
    - private 继承：基类public，protected，private ->派生类private，private，private
#### 构造函数 & 析构函数
- 构造函数：创建类的新对象时执行的函数。
    - **不返回任何类型，也不返回void类型**
    - 默认的构造函数不带参数，必要时可以自己添加参数
    - 使用**初始化列表**来初始化字段，经常在题库中节点结构体中出现
    ``` C++
    C::C( double a, double b, double c): X(a), Y(b), Z(c)
    {
      ....
    }
    ```
- [拷贝构造函数](https://www.runoob.com/cplusplus/cpp-copy-constructor.html)
    - 函数传值（对象）时，需要调用拷贝构造函数
    - 一个对象需要另一个对象初始化时，需要调用拷贝构造函数
- **为什么构造函数不可以是虚函数？**
    - 在构造函数执行之前，对象的虚函数表指针vptr还没有初始化，找不到虚函数表来实现虚调用
    - 构造子类是要从父类开始一步一步构造的，不能跳过父类的构造函数

- 析构函数：删除对象时执行的函数。
    - 形式类似于构造函数，只是在函数名前加~
    - 有助于在跳出程序时，释放资源
- **析构函数什么时候需要设置成虚函数？**
    - 答案在下面

#### 友元函数 & 友元类 √
- **友元函数**
    - 不是成员函数
    - 在函数原型前加关键字**friend**

- 友元类
    - 在类的声明前加关键字**friend**
    - 友元类的所有成员函数都是那个类的友元函数
#### 内联函数 ？
- 在函数原型前添加关键字**inline**
- 在类定义中定义的函数都是内联函数，即使没有使用inline关键字
- 如果一个函数是内联函数，那么在编译时，编译器会将该函数的代码副本放置在每个调用该函数的地方。(减少编译时在调用时写成函数开销？)

#### 静态成员 static
**1. 静态成员变量**
- 无论创建多少个类的对象，**静态成员都只有一个副本**
- 静态成员在类的所有对象中是共享的
- **不可以在类的定义(.h)中初始化静态成员变量**
*声明，要带双冒号*
``` C++
int Box::objectCount = 0;
```
*使用，要带双冒号*
``` C++
cout << "Total objects: " << Box::objectCount << endl;
```
**2. 静态成员函数**
- 静态成员函数在类的对象还没被创建的条件下也可以被调用，只要使用**类名带上双冒号**
- 静态成员函数与任何特定的对象独立开来，所以**不能使用this指针**访问
- 只能访问静态成员，静态成员变量和静态成员函数
``` C++
    static int getCount()
      {
         return objectCount;
      }
```

#### this指针
- 每个对象都可以通过this指针访问自己的地址
- this指针是类的所有成员函数的隐式参数，可以在成员函数内部直接使用this指针访问调用对象
``` C++
    double Volume()
      {
         return length * breadth * height;
      }
      int compare(Box box)
      {
         return this->Volume() > box.Volume();
      }
```
- 友元函数没得使用this指针，因为友元函数不是类的成员函数

## C++多态
#### 静态多态 vs 动态多态
##### 1. 静态多态
- 通过**函数重载、泛型编程（模板函数/模板类）**
- 在**编译**的时候就确定了实际调用的函数
##### 2. 动态多态
- 通过**虚函数**机制实现
    - 客户端的代码通过指向基类的**引用或指针**来操作子类对象，对虚函数的调用会自动绑定到实际提供的子类对象。
- 在**运行**时，通过实际的调用对象确定调用的是基类还是派生类的**同名成员函数**
##### 总结
- 不同点
    - 静态多态和动态多态本质不同，静态多态是在编译期决定，而动态多态是在运行期决定
    - 动态多态的接口是显式的，以函数签名为中心，多态通过虚函数在运行期实现，而静态多态的接口是隐式的，以有效表达式为中心，多态通过模板具现在编译期实现
- 相同点
    - 都能够实现多态
    - 都能够使接口与实现分离，静态多态是模板定义接口，类型参数定义实现，而动态多态是基类虚函数定义接口，继承类实现

#### C++重载运算符 & 重载函数
*调用重载函数或重载运算符时，编译器会进行重载决策，选择合适的重载函数或重载运算符*
- 函数重载：函数名相同，但参数列表必须不同
- 运算符重载
    - 是一个带有特殊名称的**函数**
    - 函数名是由关键字**operator**和运算符符号构成，和其他函数一样有返回类型和参数列表
    ``` C++
        Box operator+(const Box&);
    ```

#### 虚函数
- 为了让基类指针或引用可以访问到派生类的成员函数
- 基类声明函数要加关键字**virtual**，即**虚函数**
- 派生类重新定义基类的虚函数时，会告诉编译器不要静态链接到基类的函数
- 派生类对象调用此函数时，编译器会根据对象类型**动态链接**到派生类的函数

#### 虚函数表
- 虚函数表是属于类的，不是属于某个具体的对象的
- 含有虚函数的类的每一个对象都有一个虚表指针vptr，指向虚表
- 编译器会为每一个有n个虚函数的类创建一个虚函数表，每一行存一个函数指针，大小为n*4个字节
- 当**使用基类指针来操作派生类**时，虚函数表就尤为重要，用来**指明实际上该调用的函数**

#### 纯虚函数
- 在基类定义虚函数时，又不对虚函数给出实现，这时候会用到纯虚函数
- 用=0告诉编译器，这个虚函数没有主体
- 纯虚函数只有在派生类实现了才可以被使用，因为在基类只有声明
- 实现了纯虚函数的派生类，这个函数就成为了这个派生类的虚函数
``` C++
virtual int area() = 0;
```

#### 没有使用多态 vs 使用多态
##### 1. 没有使用多态
先调用派生类析构函数，后（总是会）调用基类析构函数
``` C++
    ClxDerived *p =  new ClxDerived;
    p->DoSomething();
    delete p;
```
##### 2. 使用多态
- 基类**析构函数**不是虚函数
只调用基类析构函数，没有释放派生类资源，造成内存泄漏
``` C++
    ClxBase *p =  new ClxDerived;
    //当基类Dosomething()不是虚函数时，基类的指针将表现为基类的行为
    p->DoSomething();
    delete p;
```
- 基类**析构函数**是虚函数
先调用派生类析构函数，后（总是会）调用基类析构函数
``` C++
    ClxBase *p =  new ClxDerived;
    //当基类Dosomething()是虚函数时，基类的指针将表现为派生类的行为，这就是多态的意义！
    p->DoSomething();
    delete p;
```

## C++动态内存 √
#### C++程序中内存
- 栈：管理函数内部声明的所有**变量**
- 堆：管理程序中未使用的内存，在程序运行时可用于**动态分配**内存

#### new & delete
##### new
- 用来从**自由存储区**请求分配内存，并用指针指向这块内存
- **new vs malloc()函数 √**
    - new
        - 返回指定类型的指针
        - 用delete关键字释放内存
        ``` C++
        int* p = new int;
	    *p = 10; // 假如未初始化，就会随机分配一个值
	    cout << *p << endl;
        delete p;
	    p = NULL; // 要重新初始化为NULL，否则会被随机分配一个地址
	    cout << p << endl;
        ```
    - malloc()：是库函数，包含在头文件"malloc.h"中，用于在**堆**上申请一块连续的指定大小的内存空间
        - 返回void*，需要强制类型转换成对应的指针类型
        - 用free()函数释放内存
        - 可以通过realloc()函数重新分配内存
        ``` C++
        const int size = 2000;
	    int* p = (int*)malloc(20 * sizeof(int));
	    *p = 0;
	    cout << p << endl;
	    p = (int*)realloc(p, size * sizeof(int));
	    *p = 1;
	    cout << p << endl;
	    free(p);
	    cout << p << endl;// 本身没有释放
	    cout << *p << endl;// 指向的内容被释放
        ```

- **为什么不抛弃malloc**
    - c程序只能用malloc和free来管理内存
##### delete
- 用来释放指针指向的内存

#### 数组的动态内存分配 √
``` C++
int **array;
// 假定数组第一维长度为 m， 第二维长度为 n
// 动态分配空间
array = new int *[m];
for( int i=0; i<m; i++ )
{
    array[i] = new int [n]  ;
}
//释放
for( int i=0; i<m; i++ )
{
    delete [] arrary[i];
}
delete [] array;
```
要注意对指针初始化，否则在使用时会出错。
``` C++
int *pia = new int[10]; // 每个元素都没有初始化
int *pia2 = new int[10] ();  // 每个元素初始化为0
```

#### 对象的动态内存分配
和普通的数据类型雷同，创建一个对象则调用一次构造函数，删除一个对象就调用一次析构函数
``` C++
#include <iostream>
using namespace std;
 
class Box
{
   public:
      Box() { 
         cout << "调用构造函数！" <<endl; 
      }
      ~Box() { 
         cout << "调用析构函数！" <<endl; 
      }
};
 
int main( )
{
   Box* myBoxArray = new Box[4];
 
   delete [] myBoxArray; // 删除数组
   return 0;
}
```
输出
``` C++
调用构造函数！
调用构造函数！
调用构造函数！
调用构造函数！
调用析构函数！
调用析构函数！
调用析构函数！
调用析构函数！
```

## [C++模板](https://www.runoob.com/cplusplus/cpp-templates.html) √ √ √ √
- 模板是泛型编程的基础，泛型编程就是以一种独立于任何特定类型的方式编写代码
- 库容器也就使用了模板的概念
#### 函数模板
- 函数模板不可以设置默认模板实参
- 函数模板不允许自动类型转换
``` C++
template <class type> 
ret-type func-name(parameter list)
{
   // 函数的主体
}
```
#### 类模板
``` C++
template <class T>
class Stack { 
  private: 
    vector<T> elems;     // 元素 
 
  public: 
    void push(T const&);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
}; 
```
类定义的函数成员的实现要带有template开头
``` C++
template <class T>
void Stack<T>::push (T const& elem) 
{ 
    // 追加传入元素的副本
    elems.push_back(elem);    
} 
```


## C++资源库
#### C++STL 标准模板库
##### 容器
- queue
- list
- vector
- map
##### 算法
- 作用于容器
- 对容器内容进行初始化、排序、搜索、转换等
##### 迭代器
- 作用于容器或容器子集
- 遍历集合的元素
``` C++
    // 使用迭代器 iterator 访问值
    vector<int>::iterator v = vec.begin();
    while( v != vec.end()) {
        cout << "value of v = " << *v << endl;
        v++;
   }
```
- 要点说明
    - begin()返回指向向量开头的迭代器
    - end()返回指向向量末尾的迭代器
    - 迭代器的用法有点类似指针，用间址符*获取内容，用++移动位置

## C++标准库
#### 标准函数库
math/malloc.h等
#### 标准模板库 STL
详见Output.md
##### string类
##### vector
- 底层是顺序表（数组）
- 动态数组，在堆中分配内存，连续存放
- 内存分配：
    - reserve(n) 强制重新分配内存
    - resize(n) 构造指定长度的数组
    - clear()和erase() 都只是清空数据，而没有释放内存，只有调用析构函数才会释放
- 特点：
    - 可以快速访问任意元素，用[]操作符
    - 只能快速在最后添加或删除元素
##### list
- 底层是双向链表
- 内存空间可以不是连续的，通过指针来访问数据
- 特点：
    - 只能快速访问最开始和最后的元素
    - 可以快速在任何位置添加或删除元素
##### deque
- 底层是双端队列
- 支持在两端操作：push_back,push_front,pop_back,pop_front
- 和vector类似，但存储方式不同，deque是按页或块来分配存储器，是分段连续的；vector时分配一段连续的内存
- 特点：
    - 可以快速访问任意元素，用[]操作符
    - 可以快速插入或删除两端的元素
##### priority_queue 优先队列
- 用heap堆来实现，heap是基于vector实现的
##### map
- 底层是红黑树
##### unordered_map
- 底层是哈希表
##### set
- 底层是红黑树
##### hash_set
- 底层是哈希表

## [C++11新特性（2011年）](http://c.biancheng.net/cplus/11/)√ √ √ √ √
#### POD(Plain Old Data)类型
1. 没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数
2. 不包含虚函数和抽象类
3. 非静态成员必须声明为public
4. 类的第一个非静态成员的类型不是基类
5. 在类或者结构体继承时，要满足两种情况：
    1. 派生类中有非静态成员，且只有一个仅包含静态成员的基类
    2. 基类有非静态成员，而派生类没有非静态成员

#### auto
用于自动推断变量的类型
- 限制
    - 必须在创建对象时初始化，因为编译器要推断它的实际类型。因此，auto不能在函数的  参数中使用，因为没有初始化
    - 不能作用于类的非静态成员变量（？）
    - 不能定义数组（？）
    - 不能用于模板参数
    - 不保留引用类型
- 应用
    - 定义迭代器
    ``` C++
    vector<int> v;
    //vector<int>::iterator it=v.begin();
    auto it=v.begin();
    ```

#### decltype
与auto类似
- 可以在创建时不初始化
- 可以保留引用类型，而auto不保留引用类型

#### 使用using定义别名
代替typedef，比typedef更加清晰
``` C++
//typedef unsigned int uint_t;
using uint_t = unsigned int;

// typedef map<string,int>map_int_t;
using map_int_t = map<string, int>;
```

#### 支持函数模板的默认模板参数
以前只支持类模板的默认模板参数，不支持函数模板的默认模板参数
``` C++
template<typename T=int>
void func(void){
    ...
}
```

#### 提出列表初始化
- 原有
    - 数组列表初始化
    - POD类型列表初始化
- 新增
    - 用于任何类型对象，好处是统一了各种对象的初始化方式
    - 可以直接在变量名后面加上初始化列表，对对象进行初始化
    ``` C++
    Foo a1{123};
    int a2{123};
    ```
    - 动态内存分配
    ``` C++
    int *arr=new int[3]{1,2,3};
    ```
    - 先创建匿名对象后赋值
    ``` C++
    double d=double{3.14};
    ```

#### for循环的新用法
- 基于范围的for循环
``` C++
vector<int>arr={1,2,3};
// n表示数组中的一个元素
for(auto n:arr){
    cout<<n<<endl;
}
```
- :后面可以是表达式，只会调用一次，使用表达式返回的容器为范围进行迭代

#### Lambda函数
- 是一种匿名函数
- Lambda表达式把函数看作对象
- 与js不同，变量传递有传值和传引用的区别
``` C++
    auto f=[](int x, int y) -> int { int z = x + y; return z + x; }
    cout<<f(1,2)<<endl;
```
- 可以省略返回值定义，去掉箭头
``` C++
    [this]() { this->someFunc(); }();
```
- []传入已定义的变量，即捕获变量，传值或传引用的方式都可以
```C++
    []      // 沒有定义任何变量。使用未定义变量会引发错误。
    [x, &y] // x以传值方式传入（默认），y以引用方式传入。
    [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
    [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
    [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```
- 实际应用示例
``` C++
vector<int>v={1,2,3,4,5};
int even_count=0;
for_each(v.begin(),v.end(),[&even_count](int val){
    if(val%2==0){
        even_count++;
    }
})
cout<<even_count<<endl;
```
    
#### 非受限union
- C++11允许union有静态成员，但是静态成员变量只能**在union内定义**，也**不能在union外使用**
- C++11规定，如果union内有非POD成员，且该成员有自定义的构造函数，那么这个union的默认构造函数就会被编译器删除，其他的特殊成员函数（默认拷贝构造函数，析构函数等）也会被删除
*在下面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。*
``` C++
#include <string>
using namespace std;
union U {
    string s;
    int n;
};
int main() {
    U u;   // 构造失败，因为 U 的构造函数被删除
    return 0;
}
```
*解决：在构造union时用placement new调用string类的构造函数，注意在析构union时也要调用string类的析构函数*
``` C++
#include <string>
using namespace std;
union U {
    string s;
    int n;
public:
    U() { new(&s) string; }
    ~U() { s.~string(); }
};
int main() {
    U u;
    return 0;
}
```
