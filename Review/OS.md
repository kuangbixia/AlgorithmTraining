# 复盘
## 操作系统
#### OS设计总结
- 以多进程形式，允许多个任务同时进行
- 以多线程形式，允许单个任务分成不同的部分运行
- 提供协调机制，一方面防止进程之间产生冲突，另一方面允许进程和线程之间共享资源

#### [进程和线程](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
##### 进程
- 是正在运行的程序的实例
- 进程是资源分配的基本单位
- 可以包含多个线程
- 用PCB（进程控制块/进程表）和状态队列实现
##### 线程
- 线程是cpu调度的基本单位
- 包含在进程里
- 用TCB实现
- 线程共享了进程的上下文，因此统一进程的线程之间要进行**同步**和**互斥**

#### 进程的三种状态 & 转换
##### 三种状态
1. ready 就绪状态
    进程已经被分配到**除CPU以外**的所有必要资源，只要获得处理机CPU就可以执行
2. running 执行状态
    进程已经获得处理机CPU，正在CPU上执行
3. blocked 阻塞状态
    正在running执行的进程，由于等待某个事件发生，而无法继续执行，便放弃CPU，挂起，处于阻塞状态。如：等待I/O完成，等待信号，申请缓冲区不能满足等。
##### 状态转换
1. ready -> running
    **就绪**状态的进程，获得了CPU，转换成**执行**状态
2. running -> ready
    **执行**状态的进程，因为用**完分配的时间片**，不得不让出CPU，转换成**就绪**状态
3. running -> blocked
    **执行**状态的进程，因为等待某个事件发生，无法继续执行，转换成**阻塞**状态
4. blocked -> ready
    **阻塞**状态的进程，如果等待的事件已经发生，就又可以转换成**就绪**状态，再次等待获得CPU，重新进入**执行**状态

#### 进程间通信


#### 线程同步的方式
- 车间内的工人共享车间的空间，即每个线程共享同一进程里的内存。
- 某些内存区域，只能提供给固定数量的线程使用。
##### 互斥锁
- 只允许一个线程同一时刻访问同一资源
- 用来防止多个线程同时读写某一块内存区域
- 车间里的某些房间只容纳一个工人，会在门口上一把锁，先到的人锁上门，其他人排队，直到锁打开
##### 信号量
- 允许多个线程同一时刻访问同一资源，但需要控制最大线程量
- 用来保证多个线程之间不会互相冲突
- 车间里的某些房间只容纳n个工人，会在门口放上n把钥匙，先到的人就取一把钥匙开门进去，出来再把钥匙挂回原处，钥匙架空的时候其他人必须排队


#### 死锁
- 产生死锁四个必要条件
    - 互斥条件：一段时间内某一资源仅为一个进程所占用
    - 请求和保持条件：当进程因请求资源而阻塞时，**对已获得的资源保持不放**
    - 不剥夺条件：进程已获得的资源在**未使用完之前不可剥夺**，只能在使用完后自己释放
    - 循环等待条件：在发生死锁时，必然存在一个进程-资源的环形链
- 预防死锁
    - 破坏请求条件：一次性分配所有资源
    - 破坏保持条件：只要有一个资源没得到分配，就不给这个进程分配其他资源
    - 破坏不可剥夺条件：当进程已获得部分资源，但得不到其他资源，则释放已占有的资源
    - 破坏环路等待条件：系统给每一类资源编号，每个进程按编号递增的顺序请求资源，释放则相反

#### 虚拟内存和物理内存
