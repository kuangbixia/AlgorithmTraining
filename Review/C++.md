# C++
## C++基础
#### 琐碎
##### static变量
- 在函数内声明，也可以在函数外共用。
- 作为全局变量。
##### 定义常量
1. #define
2. const
##### 野指针问题
- 创建指针后要初始化为NULL，否则他的缺省值是随机的。
- 当使用delete释放空间后，要设为NULL，否则会被随机分配，可能导致和其他指针指向同一块地址，造成后续访问或者写入冲突。
##### 一个类A包含另一个已经包含类A的类B
- 直接include会导致死循环，编译错误。
- 解决方法
    - 在类A头文件中声明类B
    ``` C++
    #ifndef AH
    #define AH
    class B;
    class A {
    public:
        B* b;
        ~A();
    };
    #endif
    ```
    - 在类A的cpp文件中除了包含类A，还要**包含类B**
    ``` C++
    #include "A.h"
    #include "B.h"
    A::~A() {
    }
    ```
##### 内存对齐
- 根据有效对齐单位确定 #pragma back(n)，一般是4个字节
- [参考](https://zhuanlan.zhihu.com/p/30007037)
##### sizeof
*所占内存的字节数*
- 指针：无论指向什么类型，都是4个字节。
- 数组名：整个数组占的字节
- 结构体：要注意内存对齐问题


#### C++存储类
##### auto
- 用于自动推断变量的类型
- C++11 中已删除
##### static ▲
1. 修饰局部变量时，可以在函数调用之间保持局部变量的值，即不需要再每次进入和离开作用域时重复进行创建和销毁
2. 可以应用于全局变量，作用域为**声明它的文件**
3. 可以用于类的数据成员上，表示被类的所有对象共享
##### extern ▲
- 提供全局变量的引用
- 对**所有的程序文件**都可见


#### 函数参数
##### 传值调用
- 将参数的实际**值**复制给函数的形式参数
- 修改函数内的形式参数**不会**影响实际参数
##### 指针调用
- 将参数的**地址**复制给函数的形式参数
- 因此，修改函数内的形式参数**会影响**到实际参数
##### 引用调用
- 将引用的**地址**复制给函数的形式参数，该引用用于访问调用中要用到的实际参数
- 因此，修改函数内的形式参数**会影响**实际参数
##### 传递数组 √
*实际上传的都是地址*
1. 形式参数是一个指针
``` C++
void myFunction(int *param)
{
}
```
2. 形式参数是一个已定义大小的数组
``` C++
void myFunction(int param[10])
{
}
```
3. 形式参数是一个未定义大小的数组
``` C++
void myFunction(int param[])
{
}
```
##### 返回数组/指针 √
*C++不允许返回一个完整的数组，可以通过数组名返回一个指向数组的指针*
``` C++
int * getRandom( )
{
  static int  r[10];
 
  // 设置种子
  srand( (unsigned)time( NULL ) );
  for (int i = 0; i < 10; ++i)
  {
    r[i] = rand();
    cout << r[i] << endl;
  }
 
  return r;
}
```
##### 返回引用
*跟返回指针类似*
``` C++
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}
```
*返回的被引用的对象不能超过作用域，即返回函数内的局部变量的引用是非法的*
``` C++
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```


#### Lambda函数（C++11提供）
- 匿名函数
- Lambda表达式把函数看作对象
- 与js不同，变量传递有传值和传引用的区别
``` C++
    [](int x, int y) -> int { int z = x + y; return z + x; }
```
``` C++
    [this]() { this->someFunc(); }();
```
- []传入已定义的变量，传值或传引用的方式都可以
```C++
    []      // 沒有定义任何变量。使用未定义变量会引发错误。
    [x, &y] // x以传值方式传入（默认），y以引用方式传入。
    [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
    [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
    [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```


#### 随机数
1. srand(...)设置种子
2. rand()生成实际的随机数


#### 指针
##### 指针vs数组名
- 指向数组开头的指针可以通过指针的算术运算来访问数组
-  数组名也可以应用*，+，-等运算符，但不可以使用++，--，因为修改数组名的值是非法的，数组名是一个指向数组开头的**常量**，不能作为左值
##### 指向指针的指针
**冷静区别** & 是对变量取地址，* 是对变量取值即可。


#### 引用
##### 引用和指针的区别
- 不存在空引用。可以有空指针，而且最好在创建指针时初始化为NULL。
- 引用必须在创建时初始化。指针可以随时初始化。
``` C++
int i = 17;
int&  r = i;
```
- 一旦引用被初始化为一个对象，就不能被指向另一个对象。指针可以随时指向另一个对象。




## C++数据抽象 & 数据封装
- 数据抽象：仅向用户暴露接口而隐藏具体的实现细节的机制。用**类**来定义抽象的数据类型。
- 数据封装：把数据和操作数据的函数捆绑在一起的机制。




## C++抽象类
- 含有至少一个**纯虚函数**
- **不可以被实例化**
- 被当作**接口**来使用




## C++面向对象
#### 类
##### 访问修饰符
- public 公有成员：在类的外部可访问
- private 私有成员：类定义中未加修饰符的**默认为私有**，除了**类内部和友元函数**，在类的外部不可访问
- protected 受保护成员：除了**派生类**，在类的外部不可访问
##### 类的继承
- is a关系
- 可以多继承
``` C++
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```
- 继承类别
    - public 继承：基类public，protected，private ->派生类public，protected，private
    - protected 继承：基类public，protected，private ->派生类protected，protected，private
    - private 继承：基类public，protected，private ->派生类private，private，private
##### 构造函数 & 析构函数
- 构造函数：创建类的新对象时执行的函数。
    - **不返回任何类型，也不返回void类型**
    - 默认的构造函数不带参数，必要时可以自己添加参数
    - 使用**初始化列表**来初始化字段，经常在题库中节点结构体中出现
    ``` C++
    C::C( double a, double b, double c): X(a), Y(b), Z(c)
    {
      ....
    }
    ```
- [拷贝构造函数](https://www.runoob.com/cplusplus/cpp-copy-constructor.html)
- 析构函数：删除对象是执行的函数。
    - 形式类似于构造函数，只是在函数名前加~
    - 有助于在跳出程序时，释放资源
##### 静态成员 static
**1. 静态成员变量**
- 无论创建多少个类的对象，静态成员都只有一个副本
- 静态成员在类的所有对象中是共享的
- **不可以在类的定义(.h)中初始化静态成员**
*声明，要带双冒号*
``` C++
int Box::objectCount = 0;
```
*使用，要带双冒号*
``` C++
cout << "Total objects: " << Box::objectCount << endl;
```
**2. 静态成员函数**
- 静态成员函数在类的对象还没被创建的条件下也可以被调用，只要使用**类名带上双冒号**
- 静态成员函数与任何特定的对象独立开来，所以**不能使用this指针**访问
- 只能访问静态成员，静态成员变量和静态成员函数
``` C++
    static int getCount()
      {
         return objectCount;
      }
```
##### 友元函数 & 友元类 √
- **友元函数**
    - 不是成员函数
    - 在函数原型前加关键字**friend**

- 友元类
    - 在类的声明前加关键字**friend**
    - 友元类的所有成员函数都是那个类的友元函数
##### 内联函数 ？
- 在函数原型前添加关键字**inline**
- 在类定义中定义的函数都是内联函数，即使没有使用inline关键字
- 如果一个函数是内联函数，那么在编译时，编译器会将该函数的代码副本放置在每个调用该函数的地方。(减少编译时在调用时写成函数开销？)
##### this指针
- 每个对象都可以通过this指针访问自己的地址
- this指针是类的所有成员函数的隐式参数，可以在成员函数内部直接使用this指针访问调用对象
``` C++
    double Volume()
      {
         return length * breadth * height;
      }
      int compare(Box box)
      {
         return this->Volume() > box.Volume();
      }
```
- 友元函数没得使用this指针，因为友元函数不是类的成员函数
##### 指向类的指针
- 类似于指向结构体的指针
- 和所有指针一样，在**使用指针前必须先初始化指针**




## C++多态
#### C++重载运算符 & 重载函数
*调用重载函数或重载运算符时，编译器会进行重载决策，选择合适的重载函数或重载运算符*
- 函数重载：函数名相同，但参数列表必须不同
- 运算符重载
    - 是一个带有特殊名称的**函数**
    - 函数名是由关键字**operator**和运算符符号构成，和其他函数一样有返回类型和参数列表

#### 虚函数
- 基类声明函数要加关键字**virtual**，即**虚函数**
- 派生类重新定义基类的虚函数时，会告诉编译器不要静态链接到基类的函数
- 派生类对象调用此函数时，编译器会根据对象类型**动态链接**到派生类的函数

#### 虚函数表
- 编译器会为每一个有n个虚函数的类创建一个虚函数表，每一行存一个函数指针，大小为n*4个字节
- 当**使用基类指针来操作派生类**时，虚函数表就尤为重要，用来**指明实际上该调用的函数**

#### 纯虚函数
- 在基类定义虚函数时，又不对虚函数给出实现，这时候会用到纯虚函数
- 用=0告诉编译器，这个虚函数没有主体
``` C++
virtual int area() = 0;
```
#### 没有使用多态
先调用派生类析构函数，后（总是会）调用基类析构函数
``` C++
    ClxDerived *p =  new ClxDerived;
    p->DoSomething();
    delete p;
```
#### 使用多态
##### 基类析构函数不是虚函数
只调用基类析构函数，没有释放派生类资源，造成内存泄漏
``` C++
    ClxBase *p =  new ClxDerived;
    //当基类Dosomething()不是虚函数时，基类的指针将表现为基类的行为
    p->DoSomething();
    delete p;
```
##### 基类析构函数是虚函数
先调用派生类析构函数，后（总是会）调用基类析构函数
``` C++
    ClxBase *p =  new ClxDerived;
    //当基类Dosomething()是虚函数时，基类的指针将表现为派生类的行为，这就是多态的意义！
    p->DoSomething();
    delete p;
```




## [C++模板](https://www.runoob.com/cplusplus/cpp-templates.html)
- 模板是泛型编程的基础，泛型编程就是以一种独立于任何特定类型的方式编写代码
- 库容器也就使用了模板的概念
#### 函数模板
``` C++
template <class type> 
ret-type func-name(parameter list)
{
   // 函数的主体
}
```
#### 类模板
``` C++
template <class T>
class Stack { 
  private: 
    vector<T> elems;     // 元素 
 
  public: 
    void push(T const&);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
}; 
```
类定义的函数成员的实现要带有template开头
``` C++
template <class T>
void Stack<T>::push (T const& elem) 
{ 
    // 追加传入元素的副本
    elems.push_back(elem);    
} 
```



## C++预处理器
#### 宏/常量
使用#define来创建符号常量
``` C++
#include <iostream>
using namespace std;
 
#define PI 3.14159
 
int main ()
{
 
    cout << "Value of PI :" << PI << endl; 
 
    return 0;
}
```
#### 参数宏
使用#define来定义一个带有参数的宏，相当于函数来使用
``` C++
#include <iostream>
using namespace std;
 
#define MIN(a,b) (a<b ? a : b)
 
int main ()
{
   int i, j;
   i = 100;
   j = 30;
   cout <<"较小的值为：" << MIN(i, j) << endl;
 
    return 0;
}
```




## C++动态内存 √
#### C++程序中内存
- 栈：管理函数内部声明的所有**变量**
- 堆：管理程序中为使用的内存，在程序运行时可用于**动态分配**内存

#### new & delete
##### new
- 用来请求分配内存，并用指针指向这块内存
- **new vs malloc()函数 √**
    - new：返回指定类型的指针
    - malloc()：用于申请一块连续的指定大小的内存空间
        - 返回void*，需要强制类型转换成对应的指针类型
        - 用free()函数释放内存
##### delete
- 用来释放指针指向的内存

#### 数组的动态内存分配 √
``` C++
int **array;
// 假定数组第一维长度为 m， 第二维长度为 n
// 动态分配空间
array = new int *[m];
for( int i=0; i<m; i++ )
{
    array[i] = new int [n]  ;
}
//释放
for( int i=0; i<m; i++ )
{
    delete [] arrary[i];
}
delete [] array;
```

#### 对象的动态内存分配
和普通的数据类型雷同，创建一个对象则调用一次构造函数，删除一个对象就调用一次析构函数
``` C++
#include <iostream>
using namespace std;
 
class Box
{
   public:
      Box() { 
         cout << "调用构造函数！" <<endl; 
      }
      ~Box() { 
         cout << "调用析构函数！" <<endl; 
      }
};
 
int main( )
{
   Box* myBoxArray = new Box[4];
 
   delete [] myBoxArray; // 删除数组
   return 0;
}
```
输出
``` C++
调用构造函数！
调用构造函数！
调用构造函数！
调用构造函数！
调用析构函数！
调用析构函数！
调用析构函数！
调用析构函数！
```



## C++资源库
#### C++STL 标准模板库
##### 容器
- queue
- list
- vector
- map
##### 算法
- 作用于容器
- 对容器内容进行初始化、排序、搜索、转换等
##### 迭代器
- 作用于容器或容器子集
- 遍历集合的元素
``` C++
    // 使用迭代器 iterator 访问值
    vector<int>::iterator v = vec.begin();
    while( v != vec.end()) {
        cout << "value of v = " << *v << endl;
        v++;
   }
```
- 要点说明
    - begin()返回指向向量开头的迭代器
    - end()返回指向向量末尾的迭代器
    - 迭代器的用法有点类似指针，用间址符*获取内容，用++移动位置

#### C++标准库
##### 标准函数库
math/malloc.h等
##### 面向对象类库
string/vector/algorithm等